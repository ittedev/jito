<!DOCTYPE html>
<meta charset="UTF-8">
<title>virtual_dom/load.test.js</title>
<link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
<div id="mocha"></div>
<script src="https://unpkg.com/chai/chai.js"></script>
<script>
var i = 0
var equal = (v, p) => chai.expect(v === undefined ? v : JSON.parse(JSON.stringify(v))).deep.equal(p)
var sleep = t => new Promise(r => setTimeout(r, t || 0))
</script>
<script src="https://unpkg.com/mocha/mocha.js"></script>
<script type="module">
import {
  MemoryHistory,
  walk,
} from '../router.js'

mocha.setup('bdd')

describe('Router', function() {
  describe('MemoryHistory', function() {
    describe('new:', function() {
      it('pushState state', () => {
        let history = new MemoryHistory()
        equal(history.state, null)
        equal(history.length, 1)
      })
    })

    describe('pushState():', function() {
      it('pushState state', () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        equal(history.state, 100)
        equal(history.length, 2)
      })
      it('pushState states', () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abc')
        equal(history.state, 200)
        equal(history.length, 3)
      })
    })

    describe('replaceState():', function() {
      it('replaceState state', () => {
        let history = new MemoryHistory()
        history.replaceState(100, '', 'abc')
        equal(history.state, 100)
        equal(history.length, 1)
      })
      it('replaceState states', () => {
        let history = new MemoryHistory()
        history.replaceState(100, '', 'abc')
        history.replaceState(200, '', 'abc')
        equal(history.state, 200)
        equal(history.length, 1)
      })
    })

    describe('go():', function() {
      it('no back', async () => {
        let history = new MemoryHistory()
        history.back()
        await sleep(1)
        equal(history.state, null)
        equal(history.length, 1)
      })

      it('back', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.back()
        equal(history.state, 100)
        equal(history.length, 2)
        await sleep(1)
        equal(history.state, null)
        equal(history.length, 2)
      })

      it('no forward', async () => {
        let history = new MemoryHistory()
        history.forward()
        await sleep(1)
        equal(history.state, null)
        equal(history.length, 1)
      })

      it('forward', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.back()
        await sleep(1)
        history.forward()
        equal(history.state, null)
        equal(history.length, 2)
        await sleep(1)
        equal(history.state, 100)
        equal(history.length, 2)
      })
      it('go -2', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abcd')
        history.go(-2)
        equal(history.state, 200)
        equal(history.length, 3)
        await sleep(1)
        equal(history.state, null)
        equal(history.length, 3)
      })
      it('go 2', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abcd')
        history.go(-2)
        await sleep(1)
        history.go(2)
        equal(history.state, null)
        equal(history.length, 3)
        await sleep(1)
        equal(history.state, 200)
        equal(history.length, 3)
      })
    })

    describe('popstate:', function() {
      it('add listener', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abcd')
        let state
        history.addEventListener('popstate', event => {
          state = event.state
        })
        history.back()
        equal(state, undefined)
        await sleep(1)
        equal(state, 100)
      })

      it('remove listener', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abcd')
        let state
        let listener = event => {
          state = event.state
        }
        history.addEventListener('popstate', listener)
        history.removeEventListener('popstate', listener)
        history.back()
        await sleep(1)
        equal(state, undefined)
      })

      it('multi listener', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abcd')
        let count = 0
        history.addEventListener('popstate', event => {
          count += 1
        })
        history.addEventListener('popstate', event => {
          count += 2
        })
        history.back()
        equal(count, 0)
        await sleep(1)
        equal(count, 3)
      })

      it('stop multi listener', async () => {
        let history = new MemoryHistory()
        history.pushState(100, '', 'abc')
        history.pushState(200, '', 'abcd')
        let count = 0
        history.addEventListener('popstate', event => {
          count += 1
          event.stopImmediatePropagation()
        })
        history.addEventListener('popstate', event => {
          count += 2
        })
        history.back()
        equal(count, 0)
        await sleep(1)
        equal(count, 1)
      })
    })
  })

  describe('walk()', function() {
    describe('new:', function() {
      it('history', () => {
        let router = walk(history)
        equal(router.size, 0)
        equal(router.panel, null)
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })
      it('MemoryHistory', () => {
        let history = new MemoryHistory()
        let router = walk(history)
        equal(router.size, 0)
        equal(router.panel, null)
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })
    })

    describe('page():', function() {
      it('page single string', () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page } = router
        page('a')

        equal(router.size, 1)
      })

      it('page empty string', () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page } = router
        page('')

        equal(router.size, 1)
      })

      it('page slashed string', () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page } = router
        page('a/b')

        equal(router.size, 1)
      })

      it('page has a param', () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page } = router
        page(':param1/b')

        equal(router.size, 1)
      })

      it('multi page', () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page } = router
        page('a/b')
        page(':param1/b')

        equal(router.size, 2)
      })
    })

    describe('open():', function() {
      it('open single string', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a')

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open single string fail', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a')

        let result = ''
        await open('b')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'fail')
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open empty string', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('')

        let result = ''
        await open('')
        .then(() => { result = 'success' })
          .catch(() => { result = 'fail' })
        equal(result, 'success')
        equal(router.pathname, '')
        equal(router.pattern, '')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open empty string fail', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('')

        let result = ''
        await open('a')
          .then(() => { result = 'success' })
          .catch(() => { result = 'fail' })
        equal(result, 'fail')
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open slashed string', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a/b')

        let result = ''
        await open('a/b')
          .then(() => { result = 'success' })
          .catch(() => { result = 'fail' })
        equal(result, 'success')
        equal(router.pathname, 'a/b')
        equal(router.pattern, 'a/b')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open slashed string fail', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a/b')

        let result = ''
        await open('a/a')
          .then(() => { result = 'success' })
          .catch(() => { result = 'fail' })
        equal(result, 'fail')
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open has a param', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page(':param1/b')

        let result = ''
        await open('a/b')
          .then(() => { result = 'success' })
          .catch(() => { result = 'fail' })
        equal(result, 'success')
        equal(router.pathname, 'a/b')
        equal(router.pattern, ':param1/b')
        equal(router.params, { param1: 'a' })
        equal(router.props, {})
        equal(router.query, {})
      })

      it('multi open', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page(':param1/b')
        page('a/:param2')

        let result = ''
        await open('a/b')
          .then(() => { result = 'success' })
          .catch(() => { result = 'fail' })
        equal(result, 'success')
        equal(router.pathname, 'a/b')
        equal(router.pattern, 'a/:param2')
        equal(router.params, { param2: 'b' })
        equal(router.props, {})
        equal(router.query, {})
      })

      it('open has props', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a')

        let result = ''
        await open('a', { name: 'Jito' })
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, { name: 'Jito' })
        equal(router.query, {})
      })

      it('open has query', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a')

        let result = ''
        await open('a', null, { name: 'Jito' })
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, { name: 'Jito' })
      })
    })

    describe('next():', function() {
      it('not use next through', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', () => {})

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('next through', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ next }) => next())

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('next change props', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ next }) => next({ name: 'Jito' }))

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, { name: 'Jito' })
        equal(router.query, {})
      })

      it('next change query', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ next }) => next(null, { name: 'Jito' }))

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'a')
        equal(router.pattern, 'a')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, { name: 'Jito' })
      })
    })

    describe('block():', function() {
      it('not use block', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', () => false)

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'fail')
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('use block', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ block }) => block())

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'fail')
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })
    })

    describe('redirect():', function() {
      it('redirect', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ redirect }) => redirect('b'))
        page('b')

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'b')
        equal(router.pattern, 'b')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('redirect fail', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ redirect }) => redirect('b'))

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'fail')
        equal(router.pathname, null)
        equal(router.pattern, null)
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })

      it('redirect has props and query', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ redirect }) => redirect('b'))
        page('b')

        let result = ''
        await open('a', { name: 'Beako' }, { name: 'Jito' })
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'b')
        equal(router.pattern, 'b')
        equal(router.params, {})
        equal(router.props, { name: 'Beako' })
        equal(router.query, { name: 'Jito' })
      })

      it('multi redirect', async () => {
        let history = new MemoryHistory()
        let router = walk(history)
        let { page, open } = router
        page('a', ({ redirect }) => redirect('b'))
        page('b', ({ redirect }) => redirect('c'))
        page('c')

        let result = ''
        await open('a')
          .then(() => result = 'success')
          .catch(() => result = 'fail')
        equal(result, 'success')
        equal(router.pathname, 'c')
        equal(router.pattern, 'c')
        equal(router.params, {})
        equal(router.props, {})
        equal(router.query, {})
      })
    })
  })
})

mocha.run()
</script>